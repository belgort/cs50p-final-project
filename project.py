# Final Project
# Bruce Elgort
# CS50P June, 2022
"""
Description: This program will convert closed-caption files generated by services like YouTube
and Panopto into either Markdown or HTML. There are several options available to the user to
facilitate formatting of the output file.
"""

import argparse
import sys
import os.path
from datetime import datetime


def find_nth_char(haystack, needle, n) -> int:
    """Finds a character in a string starting at a given nth position.
    Source: https://discuss.dizzycoding.com/find-the-nth-occurrence-of-substring-in-a-string/"""
    parts: list = haystack.split(needle, n + 1)
    if len(parts) <= n + 1:
        return False
    return len(haystack) - len(parts[-1]) - len(needle)


def parse_command_line() -> dict:
    """Parses the command line arguments"""
    # process.py source destination -p youtube|panopto -u url to video [-d html|markdown|text] [-e yes|no] [-t timestamps yes|no]
    parser = argparse.ArgumentParser(
        description="Generate clickable transcripts (HTML or Markdown) from closed-caption files",
        epilog="Contact belgort@clark.edu with any questions.",
    )
    parser.add_argument("source", help="Closed-Caption source file (in SRT format")
    parser.add_argument("destination", help="Destination file for HTML")
    parser.add_argument(
        "-p",
        help="Video platform",
        type=str,
        choices=["youtube", "panopto"],
        default="panopto",
    )
    parser.add_argument("-u", help="URL to video", type=str, required=True)
    parser.add_argument(
        "-d",
        help="Document type",
        type=str,
        choices=["html", "markdown", "text"],
        default="html",
    )
    parser.add_argument(
        "-t", help="Include timestamps", type=str, choices=["yes", "no"], default="yes"
    )
    parser.add_argument(
        "-e",
        help="Include HTML header and closing tags",
        type=str,
        choices=["yes", "no"],
        default="no",
    )

    args = parser.parse_args()

    # Make sure the human is not trying to overwrite this Python file :)
    if args.destination.lower() != os.path.basename(__file__):
        return {
            "source": args.source,
            "destination": args.destination.lower(),
            "d": args.d.lower(),
            "p": args.p.lower(),
            "u": args.u.lower(),
            "t": args.t,
            "e": args.e,
        }
    else:
        print("No, please don't. You are playing with fire ðŸ”¥")
        sys.exit(1)


def process_transcript(options: dict) -> None:
    """Takes the options passed to it and performs the requested conversion"""
    source: str = options["source"]
    destination: str = options["destination"]
    timestamps: str = options["t"]
    documentType: str = options["d"]
    encloseInHTML: str = options["e"]
    platform: str = options["p"]
    URL: str = options["u"]
    fileOutFolder: str = "output/"
    fileOut = open(fileOutFolder + destination, "w")

    """
    Notes:
    YouTube URL query param &t=
    Panopto URL query param &start=
    """
    match platform:
        case "panopto":
            URL += "&start="
        case "youtube":
            URL += "&t="

    match documentType:
        case "html":
            if encloseInHTML == "yes":
                with open("parts/html_skeleton.html") as file:
                    for line in file:
                        fileOut.write(line)
        case "markdown":
            with open("parts/markdown_skeleton.md") as file:
                for line in file:
                    fileOut.write(line)
        case "text":
            with open("parts/text_skeleton.txt") as file:
                for line in file:
                    fileOut.write(line)

    if not os.path.exists(source):  # make sure source file exists
        print(
            "I can't find the source file you specified ðŸ˜¢. Please verify what you typed in."
        )
        sys.exit(1)

    with open(source, "r") as fileIn:
        line = fileIn.readline()  # read first sequence
        while line:

            line = fileIn.readline()  # sequence / time
            pos: int = find_nth_char(line, ",", 0)
            time: str = str(line[:pos].split(",")[0])
            try:  # Lets make sure we have a valid timestamp
                date_time = datetime.strptime(time, "%H:%M:%S")
            except ValueError as e:
                print(
                    "Oh no ðŸ˜±! Something went wrong while processing. Please contact bruce.elgort@gmail.com"
                )
                print(f"Let him know you got this error: {e}")
                sys.exit(1)

            a_timedelta = date_time - datetime(1900, 1, 1)
            seconds = a_timedelta.total_seconds()
            line = fileIn.readline()  # text
            match documentType:
                case "html":
                    if timestamps == "yes":
                        link = f"<p>{time}&nbsp;<a href='{URL + str(int(seconds))}'>{line}</a></p>\n"
                    else:
                        link = (
                            f"<p><a href='{URL + str(int(seconds))}'>{line}</a></p>\n"
                        )
                case "markdown":
                    if timestamps == "yes":
                        link = f"{time} [{line}]({URL + str(int(seconds))}\n\n)"
                    else:
                        link = f"[{line}]({URL + str(int(seconds))}\n\n)"
                case "text":
                    if timestamps == "yes":
                        link = f"{time} {line}\n"
                    else:
                        link = f"{line}\n"

            fileOut.write(link)  # write data to the output file

            line = fileIn.readline()  # blank line
            line = fileIn.readline()  # sequence number

    match documentType:  # closing things up if needed
        case "html":
            if encloseInHTML == "yes":
                with open("parts/html_closing.html") as htmlFile:
                    for line in htmlFile:
                        fileOut.write(line)
    fileOut.close()  # Close output file


def main() -> None:
    """Mainline logic for the program"""
    options = parse_command_line()  # process command line
    process_transcript(options)  # perform conversion


if __name__ == "__main__":
    main()
